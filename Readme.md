# 计算机网络提高层实验

## 基于 Linux 内核的 CoDel 主动队列管理算法实现

18373463 熊胡超

## 背景介绍

### 主动队列管理

主动队列管理是为了避免网络中的全局同步现象（即路由器的尾部丢弃使得许多TCP连接在同一时间突然都进入到慢开始状态）而提出的。所谓的“主动”就是不等到路由器的队列长度已经到达最大值时才丢弃分组；取而代之的是在队列长度到达某个值得警惕的长度（此时可看作网络已经具有了拥塞的征兆）就开始丢弃分组。由于TCP连接使用丢包作为检测网络拥堵的手段之一，这样做就可以让发送方放慢发送的速速率，进而可能使网络的拥堵状况减轻，甚至避免网络拥堵。

### 算法概述

> 在网络路由中，CoDel（Controlled Delay，发音为“ coddle ”）是Van Jacobson和Kathleen Nichols开发的网络调度程序中使用的调度算法 。 它旨在通过设置缓冲区中网络数据包的延迟限制来克服网络硬件（如路由器）中的缓冲膨胀，改善了随机早期检测（random early detection，RED）算法的整体性能，解决了Jacobson 开发 RED 时抱有的一些误解，设计上 CoDel 比 RED 更容易管理和配置。\
> *摘自维基百科*

CoDel 的算法核心在于其以正反馈的策略来进行丢包速率的控制以实现整个队列的负反馈，进而实现对突发流量和恶意流量的约束。

### 算法对比

对比一些其他的算法，这里以RED作为相应的对照。

RED是最早提出的AQM算法之一，其使用基于队列长度的判据来决定是否丢弃数据包。

RED的第一个问题是其丢包阈值的判据问题。RED基于队列长度来判断是否需要丢包，试想：如果一个队列虽然长度很长，但出口发送速率很快。此时，恶意的流量可以不断地将队列维持在长队列水平，这样良性流量会因为过长的队列而被丢弃，无法发送。在这种情况下，RED无法做到对恶意流量的惩罚。

RED的第二个问题，也是使用RED是必须面对的一个难题：即丢弃概率p的选择。虽然可以采用固定的丢包率，但是其对网络的适应性会很差。RED使用变化的丢弃概率p：对于每一个到达的分组，都计算丢弃概率p的数值。且不去看这只中的开销，但是算法的实现就过于复杂。丢包概率要与队列长度、时间、队列阈值相关联，这其中的关系复杂性可见一斑。

CoDel则直接以网络通信中最重要的参数之一——时延来作为自己的优化目标。队列管理的最终目标应该是使得数据包的排队延时最短。

CoDel的第二个优点是其自适应的丢包率。上面已经讨论过了RED算法中过于复杂的丢包概率计算，因此引入自适应的丢包概率是合适的。

CoDel的另一个优点是其简单性。算法的简单性也提供了丰富的可扩展性。事实上，不少之后的AQM算法都是基于CoDel开发的，例如FQ_CoDel(Fair Queuing Controlled Delay)。

## 算法实现

Linux 内核代码实现简明扼要。区区几百行的程序，要看懂也很难。完成算法的实现中，实现原算法是一回事，将算法实际应用于内核又是另一回事。

Linux 有自己的流量控制程序，它被称为 `tc` (Traffic Control，流量控制)。其主要是通过在输出端口处建立一个队列来实现流量控制。这个队列被称为`Qdisc` (Queue discipline，排队规则)。CoDel在Linux 内核中的位置即在`Qdisc`层。

Linux 内核提供了丰富的编程接口。

`linux/skbuff.h` 和 `net/pkt_sched.h` 中提供了丰富的函数来实现对队列的基本操作。

- 使用`qdisc_enqueue_tail`可以将一个包放入队列尾部；
- 使用`__qdisc_dequeue_head`可以将一个包从队首取出；
- 使用`qdisc_pkt_len`可以获取包大小；
- 使用`struct Qdisc`和`struct gnet_stats_queue`可以获取队列的统计信息；
